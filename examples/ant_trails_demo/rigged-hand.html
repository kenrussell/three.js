<!DOCTYPE html>
<html lang="en">
<head>
<title>rigged hand</title>
<style>
.menu {
  position: fixed;
  bottom: 20px;
  right: 20px;
}

.button {
  display: inline-block;
  padding: 8px;
  color: #FFF;
  background-color: #555;
}

.button.enabled {
  background-color: rgb(18, 36, 70);
}

.button:hover {
  cursor: pointer;
  background-color: rgb(18, 36, 70);
}

.button.error {
  pointer-events: none;
  background-color: red;
}

.output {
  position: fixed;
  top: 40px;
  left: 20px;  
  color: #FFF;
  z-index: 2;
}



</style>
</head>
<body>  
<div id="container"></div>
<div id="info" class="output">Info about the fingers</div>
<div class="menu">
  <div class="button full-screen">Start VR Mode</div>
</div>

<script src="../../build/three.min.js"></script>
<script src="../js/controls/VRControls.js"></script>
<script src="../js/effects/VREffect.js"></script>
<script src="../js/renderers/Projector.js"></script>
<script src="//js.leapmotion.com/leap-0.6.4.js"></script>
<script src="//js.leapmotion.com/leap-plugins-0.1.10.js"></script>
<script src="leap.rigged-hand-0.1.6.js"></script>

<script>
var scene;
var camera;
var renderer;

//camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 500 );
//camera.position.y = 30;
//camera.position.z = 200;
//camera.lookAt(new THREE.Vector3(0, 0, 0));

//camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
//camera.position.fromArray([0, 160, 200]);
//camera.lookAt(new THREE.Vector3(0, 0, 0));

//camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.fromArray([0, 0, 100]);
camera.lookAt(new THREE.Vector3(0, 0, 0));

scene = new THREE.Scene();
scene.add(camera);

scene.add( new THREE.AmbientLight( 0x444444 ) );
scene.add( new THREE.PointLight( 0xffffff, 1, 1000 ) );

renderer = new THREE.WebGLRenderer( { alpha: false } );
renderer.setClearColor( new THREE.Color(0x000000) );
renderer.setSize( window.innerWidth, window.innerHeight );
container.appendChild( renderer.domElement );

var tempSphere = new THREE.Mesh(new THREE.SphereGeometry( .05 ), new THREE.MeshLambertMaterial( { shading: THREE.FlatShading } ) );
tempSphere.position.set(0, 0, -.2);
scene.add(tempSphere);

var sphereCache = new Array(10);
var activeFingers = new Array(10);

function activateSphere(i, worldFingerPosition) {
  var sphere = sphereCache[i];
  if (sphere) {
    activeFingers[i] = sphere;
    sphereCache[i] = null;
    sphere.visible = true;
  }

  var fp = worldFingerPosition;

  activeFingers[i].position.set(fp[0], fp[1], fp[2]);
  if (i == 0) {
    // console.log("position of finger 0: " + (fp[0] / 1000) + ", " + fp[1] / 1000 + ", " +  fp[2] / 1000);
  }
}

function deactivateSphere(i) {
  var sphere = activeFingers[i];
  if (sphere) {
    sphereCache[i] = sphere;
    activeFingers[i] = null;
    sphere.visible = false;
  }
}

for (var ii = 0; ii < 10; ++ii) {
  var sphere = new THREE.Mesh(new THREE.SphereGeometry( .02 ), new THREE.MeshLambertMaterial( { shading: THREE.FlatShading } ) /* new THREE.MeshBasicMaterial( { color: 0x00e0e0 } ) */ );
  activeFingers[ii] = sphere;
  sphere.visible = true;
  scene.add(sphere);
}

window.addEventListener('resize', function() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}, false);

function VREffectLoaded(error) {
  if (error) {
    fullScreenButton.innerHTML = error;
    fullScreenButton.classList.add('error');
  }
}
var vrEffect = new THREE.VREffect(renderer, VREffectLoaded);

var vrControls = new THREE.VRControls(camera);

var fullScreenButton = document.querySelector( '.full-screen' );
fullScreenButton.onclick = function() {
  vrEffect.setFullScreen( true );
  console.log('went full screen');
};

window.controller = controller = (new Leap.Controller({
  background: true,
  optimizeHMD: true
}))

controller.use('transform', {
  // This matrix flips the x, y, and z axis, scales to meters, and offsets the hands by -8cm.
  vr: true,

  // This causes the camera's matrix transforms (position, rotation, scale) to be applied to the hands themselves
  // The parent of the bones remain the scene, allowing the data to remain in easy-to-work-with world space.
  // (As the hands will usually interact with multiple objects in the scene.)
  effectiveParent: camera


//  quaternion: (new THREE.Quaternion).setFromEuler(new THREE.Euler(Math.PI * -0.3, 0, Math.PI, 'ZXY')),
//  position: new THREE.Vector3(0, 100, 0)
});


/*

controller.use('boneHand', {
  // If you already have a scene or want to create it yourself, you can pass it in here
  // Alternatively, you can pass it in whenever you want by doing
  // Leap.loopController.plugins.boneHand.scene = myScene.
  scene: scene,

  // No arm
  arm: false,

  // Need a no-op render function to prevent the boneHand plugin from throwing an exception.
  render: function(timestamp) {}
});

*/


controller.use('riggedHand', {
  parent: scene,
  camera: camera,
  positionScale: 1,
  renderFn: null,
});

controller.connect();

function animate() {
  requestAnimationFrame(animate);
  // renderer.render(scene, camera);
  var frame = controller.frame();
  if (frame) {
    var extendedFingers = 0;
    var sphereIndex = 0;
    frame.hands.forEach(function(hand) {

      hand.fingers.forEach(function(finger) {
        if (finger.extended) {
          ++extendedFingers;
	  // Note: transform plugin has a bug where it doesn't transform Pointables' stabilizedTipPosition properly.
	  // That's OK since it seems pretty laggy.
          activateSphere(sphereIndex, finger.tipPosition);
        } else {
          deactivateSphere(sphereIndex);
	}
        ++sphereIndex;
      });
    });
  }
  document.getElementById('info').innerHTML = "extended fingers: " + extendedFingers;
  vrControls.update();
  vrEffect.render(scene, camera);
}

requestAnimationFrame(animate);
</script>

</body>
</html>
